/**
 * Generic Multilink Solver Engine
 * 通用多連桿求解核心
 * 
 * 核心概念：
 * 使用 "Constructive Geometry" (建構幾何) 方法。
 * 按照定義順序，逐步計算節點座標。這適用於單自由度且無冗餘約束的機構。
 */

import { deg2rad } from '../utils.js';

/**
 * 兩圓交點 (Dyad Solver)
 */
function solveIntersectionOptions(p1, r1, p2, r2) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const d = Math.hypot(dx, dy);

    // 檢查是否有解
    if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];

    const a_dist = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const h = Math.sqrt(Math.max(0, r1 * r1 - a_dist * a_dist));

    const x2 = p1.x + a_dist * (dx / d);
    const y2 = p1.y + a_dist * (dy / d);

    const rx = -dy * (h / d);
    const ry = dx * (h / d);

    const pPlus = { x: x2 + rx, y: y2 + ry };
    const pMinus = { x: x2 - rx, y: y2 - ry };
    return [pPlus, pMinus];
}

/**
 * 自動從連桿關係推導 Dyad 步驟
 * 當使用者只定義了連桿 (Link) 而沒定義 Dyad 步驟時，此函數會自動補足。
 */
function autoDyadFromLinks(topo, params) {
    if (!topo || !topo.steps) return topo;

    const steps = [...topo.steps];
    const solved = new Set();
    const stepMap = new Map();

    // 初始化已解點 (Ground & Input Crank)
    steps.forEach(s => {
        solved.add(s.id);
        stepMap.set(s.id, s);
    });

    // 收集連桿資訊 (優先從 visualization.links 獲取，因為 Wizard 會把 bar 放到這裡)
    const barLinks = [];
    if (topo.visualization && Array.isArray(topo.visualization.links)) {
        topo.visualization.links.forEach(l => {
            if (l.p1 && l.p2) {
                // 嘗試尋找長度參數
                // 優先序：l.len_param -> l.lenParam -> topo.params[l.id]? -> l.id
                let lenParam = l.len_param || l.lenParam;
                if (!lenParam && topo.params && topo.params[l.id] !== undefined) lenParam = l.id;

                barLinks.push({ p1: l.p1, p2: l.p2, len_param: lenParam });
            }
        });
    }

    // 迭代求解所有點位
    let changed = true;
    while (changed) {
        changed = false;

        // 找出所有「未解」但連接到「兩個已解點」的點
        const candidateConnections = new Map(); // pointId -> Array of { neighborId, lenParam }

        barLinks.forEach(l => {
            const id1 = l.p1;
            const id2 = l.p2;

            // 如果 id1 已解且 id2 未解
            if (solved.has(id1) && !solved.has(id2)) {
                if (!candidateConnections.has(id2)) candidateConnections.set(id2, []);
                candidateConnections.get(id2).push({ neighborId: id1, lenParam: l.len_param });
            }
            // 如果 id2 已解且 id1 未解
            if (solved.has(id2) && !solved.has(id1)) {
                if (!candidateConnections.has(id1)) candidateConnections.set(id1, []);
                candidateConnections.get(id1).push({ neighborId: id2, lenParam: l.len_param });
            }
        });

        candidateConnections.forEach((conns, pointId) => {
            if (conns.length >= 2) {
                // 自動生成一個 dyad 步驟
                const step = {
                    id: pointId,
                    type: 'dyad',
                    p1: conns[0].neighborId,
                    r1_param: conns[0].lenParam,
                    p2: conns[1].neighborId,
                    r2_param: conns[1].lenParam,
                    sign: 1, // 預設正向
                    isAutoGenerated: true
                };
                steps.push(step);
                solved.add(pointId);
                changed = true;
            }
        });
    }

    return { ...topo, steps };
}

/**
 * Infer ground distance parameters from links between ground points.
 * This allows fixed ground bars to be driven by len_param (e.g., L4).
 */
function autoGroundDistFromLinks(topo) {
    if (!topo || !topo.steps || !topo.visualization || !Array.isArray(topo.visualization.links)) {
        return topo;
    }

    const steps = topo.steps.map(s => ({ ...s }));
    const stepMap = new Map(steps.map(s => [s.id, s]));

    topo.visualization.links.forEach((link) => {
        if (!link || !link.p1 || !link.p2) return;
        const lenParam = link.len_param || link.lenParam;
        if (!lenParam) return;

        const s1 = stepMap.get(link.p1);
        const s2 = stepMap.get(link.p2);
        if (!s1 || !s2) return;
        if (s1.type !== 'ground' || s2.type !== 'ground') return;
        if (s1.dist_param || s2.dist_param) return;
        if (s1.x === undefined || s1.y === undefined || s2.x === undefined || s2.y === undefined) return;

        const dx = s2.x - s1.x;
        const dy = s2.y - s1.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= 0) return;

        s2.dist_param = lenParam;
        s2.ref_id = s1.id;
        s2.ux = dx / dist;
        s2.uy = dy / dist;
    });

    return { ...topo, steps };
}

/**
 * 通用求解函數
 * @param {Object|string} topologyOrParams - 機構定義或參數物件
 * @param {Object} [params] - 當前參數 (如果第一個參數是拓撲)
 */
export function solveTopology(topologyOrParams, params) {
    let topology, actualParams;

    if (params) {
        topology = topologyOrParams;
        actualParams = params;
    } else {
        actualParams = topologyOrParams || {};
        topology = actualParams.topology;
        if (typeof topology === 'string') {
            try {
                topology = JSON.parse(topology);
            } catch (e) {
                console.error("Solver: Invalid Topology JSON", e);
                return { isValid: false, errorType: 'invalid_topology' };
            }
        }
    }

    if (!topology || !topology.steps) {
        return { isValid: true, points: {}, B: undefined };
    }

    // Auto-infer ground distance parameters from links (for fixed ground bars).
    topology = autoGroundDistFromLinks(topology);

    // 自動補足缺失的 Dyad 步驟
    topology = autoDyadFromLinks(topology, actualParams);

    const points = {};
    const theta = deg2rad(actualParams.thetaDeg || actualParams.theta || 0);

    // Helper to get value: either direct number or from params
    const getVal = (step, key) => {
        // 1. 直接數值 (r1_val, len_val)
        const valDirect = step[key + '_val'];
        if (valDirect !== undefined) return Number(valDirect);

        // 2. 參數名稱 (r1_param, len_param)
        const paramName = step[key + '_param'];

        // 優先從 actualParams 找 (即 Slider 傳入的值)
        if (paramName && actualParams[paramName] !== undefined) return Number(actualParams[paramName]);

        // 次之從 topology.params 找 (即預設參數值)
        if (paramName && topology.params && topology.params[paramName] !== undefined) return Number(topology.params[paramName]);

        // 3. 回退方案：如果參數名剛好是數字字串
        if (paramName && !isNaN(parseFloat(paramName))) return Number(paramName);

        return 100; // 預設 100
    };

    // --- 自動任務排序 (確保 Ground > Crank > Others) ---
    // 這樣使用者在 JSON 中不論順序如何，計算都不會因為依賴點未解而掛掉
    const sortedSteps = [...topology.steps].sort((a, b) => {
        const order = { 'ground': 0, 'input_crank': 1, 'dyad': 2, 'joint': 3 };
        const oa = order[a.type] ?? 99;
        const ob = order[b.type] ?? 99;
        if (oa !== ob) return oa - ob;

        // For ground points, resolve absolute points before dependent (ref_id) points.
        if (a.type === 'ground' && b.type === 'ground') {
            const aDep = Boolean(a.dist_param && a.ref_id);
            const bDep = Boolean(b.dist_param && b.ref_id);
            if (aDep !== bDep) return aDep ? 1 : -1;
        }

        return 0;
    });

    // 處理所有步驟
    for (const step of sortedSteps) {
        try {
            if (step.type === 'ground') {
                let x, y;

                if (step.dist_param) {
                    const dist = getVal(step, 'dist');
                    const ref = points[step.ref_id];
                    if (ref) {
                        x = ref.x + (step.ux || 0) * dist;
                        y = ref.y + (step.uy || 0) * dist;
                    } else {
                        x = step.x || 0;
                        y = step.y || 0;
                    }
                } else {
                    if (step.x_param) {
                        x = (step.x_offset || 0) + getVal(step, 'x');
                    } else {
                        x = step.x || 0;
                    }

                    if (step.y_param) {
                        y = (step.y_offset || 0) + getVal(step, 'y');
                    } else {
                        y = step.y || 0;
                    }
                }

                points[step.id] = { x: Number(x), y: Number(y) };
            }
            else if (step.type === 'input_crank') {
                const center = points[step.center];
                if (!center) throw new Error(`Missing center point ${step.center}`);

                const r = getVal(step, 'len');
                const ang = theta + (deg2rad(step.phase_offset || 0));

                points[step.id] = {
                    x: center.x + r * Math.cos(ang),
                    y: center.y + r * Math.sin(ang)
                };
            }
            else if (step.type === 'dyad') {
                const p1 = points[step.p1];
                const p2 = points[step.p2];
                if (!p1 || !p2) {
                    // console.warn(`Solver: Missing points for dyad ${step.id}`);
                    continue; // Best effort
                }
                const r1 = getVal(step, 'r1');
                const r2 = getVal(step, 'r2');
                const options = solveIntersectionOptions(p1, r1, p2, r2);

                if (!options.length) {
                    // console.warn(`Solver: No intersection for dyad ${step.id}`);
                    continue; // Best effort
                }

                let chosen = null;
                const prevPoints = actualParams && actualParams._prevPoints;
                const prev = prevPoints ? prevPoints[step.id] : null;

                if (prev) {
                    const d0 = Math.hypot(options[0].x - prev.x, options[0].y - prev.y);
                    const d1 = Math.hypot(options[1].x - prev.x, options[1].y - prev.y);
                    chosen = d0 <= d1 ? options[0] : options[1];
                } else {
                    chosen = step.sign === -1 ? options[1] : options[0];
                }
                points[step.id] = chosen;
            }
            else if (step.type === 'point_on_link') {
                const p1 = points[step.p1];
                const p2 = points[step.p2];
                if (!p1 || !p2) continue;

                const dist = getVal(step, 'dist');
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const L = Math.hypot(dx, dy);

                if (L > 0) {
                    points[step.id] = {
                        x: p1.x + (dx / L) * dist,
                        y: p1.y + (dy / L) * dist
                    };
                } else {
                    points[step.id] = { ...p1 };
                }
            }
            else if (step.type === 'joint') {
                // Static point (typically for visualization of unsolved parts)
                if (points[step.id] === undefined) {
                    points[step.id] = { x: Number(step.x || 0), y: Number(step.y || 0) };
                }
            }
        } catch (e) {
            console.error("Solver Error at step", step.id, e);
        }
    }

    // 獲取追蹤點
    const B = points[topology.tracePoint];

    // 嚴格驗證機制：檢查所有關鍵步驟是否都有解
    // 如果有 Dyad 或 Crank 解不出來 (undefined/NaN)，則視為機構卡死
    let allResolved = true;
    for (const s of topology.steps) {
        if ((s.type === 'dyad' || s.type === 'input_crank') && !points[s.id]) {
            allResolved = false;
            break;
        }
    }

    return {
        isValid: allResolved,
        points,
        B
    };
}

/**
 * 掃描 Helper
 */
export function sweepTopology(topology, params, startDeg, endDeg, stepDeg) {
    const results = [];
    const validRanges = [];
    const invalidRanges = [];
    let currentValid = null;
    let currentInvalid = null;
    let prevPoints = null;

    for (let th = startDeg; th <= endDeg; th += stepDeg) {
        const sol = solveTopology(topology, { ...params, thetaDeg: th, _prevPoints: prevPoints });
        const isValid = sol.isValid;

        results.push({
            theta: th,
            isValid,
            B: isValid ? sol.B : null,
            points: isValid ? sol.points : null
        });

        if (isValid) {
            prevPoints = sol.points;
            if (currentInvalid) { invalidRanges.push(currentInvalid); currentInvalid = null; }
            if (!currentValid) currentValid = { start: th, end: th };
            else currentValid.end = th;
        } else {
            if (currentValid) { validRanges.push(currentValid); currentValid = null; }
            if (!currentInvalid) currentInvalid = { start: th, end: th };
            else currentInvalid.end = th;
        }
    }
    if (currentValid) validRanges.push(currentValid);
    if (currentInvalid) invalidRanges.push(currentInvalid);

    return { results, validRanges, invalidRanges };
}

/**
 * 計算軌跡統計資料
 */
export function calculateTrajectoryStats(results) {
    const validPoints = results.filter(r => r.isValid && r.B).map(r => r.B);
    if (validPoints.length === 0) return null;

    const xs = validPoints.map(p => p.x);
    const ys = validPoints.map(p => p.y);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);

    return {
        rangeX: maxX - minX,
        rangeY: maxY - minY,
        totalRange: Math.hypot(maxX - minX, maxY - minY)
    };
}
